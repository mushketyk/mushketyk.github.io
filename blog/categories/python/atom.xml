<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Python | Software Developer's diary]]></title>
  <link href="http://mushketyk.github.io/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://mushketyk.github.io/"/>
  <updated>2015-09-10T22:49:04+01:00</updated>
  <id>http://mushketyk.github.io/</id>
  <author>
    <name><![CDATA[Ivan Mushketyk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Anatomy of a Python Iterator]]></title>
    <link href="http://mushketyk.github.io/blog/2015/09/07/anatomy-of-python-itertor/"/>
    <updated>2015-09-07T21:52:41+01:00</updated>
    <id>http://mushketyk.github.io/blog/2015/09/07/anatomy-of-python-itertor</id>
    <content type="html"><![CDATA[<p>Iterator is a powerful pattern that was recognized at least as early as 1994 and since then it was incorporated in syntax of almost every modern programming language.</p>

<p>Python also implements this pattern providing a pithy and concise syntax to iterate over lists, maps, dictionaries and other data structures:</p>

<pre><code class="python">for i in [1, 2, 3, 4]:
  print i
</code></pre>

<p>In this article I will write about how an iterator is used in Python, how to implement your own iterator and what types of iterators exist in Python.</p>

<!--more-->


<h2>How iterator works</h2>

<p>Iterable types in Python are not limited to built-ins. Any object can be iterated over but it needs to obey a special protocol.</p>

<p>This means the following:</p>

<ul>
<li>An object should define the <strong>__iter__</strong> method that should return an iterator object that will be used to obtain items of a collection one by one</li>
</ul>


<p>We can use <strong>list</strong> type to illustrate this:</p>

<pre><code class="python">l = [1, 2, 3, 4]
l.__iter__()
&gt;&gt;&gt; &lt;listiterator at 0x7fb685954cd0&gt;
</code></pre>

<ul>
<li>An iterator (returned by the <strong>__iter__</strong> method) should implement the <strong>next</strong> method. Each call to the <strong>next</strong> method should return the next element in a collection</li>
</ul>


<p>Let&rsquo;s see how it works with a list in Python:</p>

<pre><code class="python">it.next()
&gt;&gt;&gt; 1

it.next()
&gt;&gt;&gt; 2

it.next()
&gt;&gt;&gt; 3

 it.next()
&gt;&gt;&gt; 4
</code></pre>

<ul>
<li>When there are no more items to return the <strong>next</strong> method should raise a <strong>StopIteration</strong> exception.</li>
</ul>


<p>Let&rsquo;s see if <strong>list</strong> obeys this protocol:</p>

<pre><code class="python">it.next()
---------------------------------------------------------------------------
StopIteration                             Traceback (most recent call last)
&lt;ipython-input-11-54f0920595b2&gt; in &lt;module&gt;()
----&gt;
</code></pre>

<p>So when we write the following code:</p>

<pre><code class="python">lst = [1, 2, 3, 4]
for i in lst:
  print i
</code></pre>

<p>Python actually executes something like this:</p>

<pre><code class="python">
# Get iterator for the list
it = lst.__iter__()
try:
  while True:
    # Get next element the list
    i = it.next()

    # This is a user-defined code that is written in a "for" loop
    print i

except StopIteration:
  # We were expecting this exception so we just ignore it and do nothing
  # If an exception of any other type is raised it will propagate further
  pass
</code></pre>

<p>With this knowledge we are ready to implement our own iterator.</p>

<h2>How to implement an iterator</h2>

<p>To make this palpable, let&rsquo;s implement our own simplistic data structure. For simplicity it would be just a wrapper around Python&rsquo;s list:</p>

<pre><code class="python">class MyList(object):
     def __init__(self, lst):
         self.lst = lst
</code></pre>

<p>Now, let&rsquo;s implement the first part of Python&rsquo;s iterator protocol: define the <strong>__iter__</strong> method:</p>

<pre><code class="python">class MyList(object):
     def __init__(self, lst):
         self.lst = lst

     def __iter__(self):
         return MyIterator(self.lst)
</code></pre>

<p>We return an instance of iterator via the <strong>__iter__</strong> method. Now let&rsquo;s implement the second part of the iterator protocol: define <strong>MyIterator</strong> with the <strong>next</strong> method:</p>

<pre><code class="python">
class MyIterator(object):
    def __init__(self, lst):
        self.lst = lst
        self.pos = 0

    def next(self):
        item = self.lst[self.pos]
        self.pos += 1
        return item
</code></pre>

<p>Now we are almost done. The only thing that we still need to do is to raise the <strong>StopIteration</strong> exception if there are no more elements to return:</p>

<pre><code class="python">
class MyIterator(object):
    def __init__(self, lst):
        self.lst = lst
        self.pos = 0

    def next(self):
        if self.pos == len(self.lst):
            raise StopIteration()
        item = self.lst[self.pos]
        self.pos += 1
        return item
</code></pre>

<p>Let&rsquo;s check if it works as expected:</p>

<pre><code class="python">
for i in MyList([1, 2, 3, 4]):
    print i
   ....:
1
2
3
4
</code></pre>

<h2>Are we done?</h2>

<p>It looks like our iterator is done, but let&rsquo;s try another example with a list:</p>

<pre><code class="python">
for i in iter([1, 2, 3, 4]):
    print i

1
2
3
4
</code></pre>

<p>In this example we get an iterator for a list using <strong>iter</strong> function (that just calls <strong>__iter__</strong> method) and iterate over it. If we try to do the same with the data structure that was written in the previous section it would not work:</p>

<pre><code class="python">for i in iter(MyList([1, 2, 3, 4])):
    print i


Traceback (most recent call last):
  File "&lt;pyshell#43&gt;", line 1, in &lt;module&gt;
    for i in iter(MyList([1, 2, 3, 4])):
TypeError: 'MyList' object is not iterable
</code></pre>

<p>Why doesn&rsquo;t it work? Let&rsquo;s see what happens.</p>

<p>First of all the <strong>iter</strong> function calls the <strong>__iter__</strong> method to get an instance of <strong>MyIterator</strong>. After this Python attempts to execute something like:</p>

<pre><code class="python">for i in MyIterator([1, 2, 3, 4]):
    print i
</code></pre>

<p>And as we know when Python executes &ldquo;<strong>for</strong> &hellip; <strong>in</strong> &hellip;&rdquo; it tries to call method <strong>__iter__</strong> on an object that is placed on the right side of the <strong>in</strong> operator. So the issue is that <strong>MyIterator</strong> does not define <strong>__iter__</strong> method.</p>

<p>To make our iterator work like a built-in type we need to add <strong>__iter__</strong> method to it that would return&hellip; itself:</p>

<pre><code class="python">
class MyIterator(object):
    def __init__(self, lst):
        self.lst = lst;
        self.pos = 0

    def __iter__(self):
        return self
    ...
</code></pre>

<p>Now it should work just as built-in type:</p>

<pre><code class="python">
for i in iter(MyList([1, 2, 3, 4])):
    print i

1
2
3
4
</code></pre>

<h2>Reverse iterator</h2>

<p>If you need to iterate over a collection in the reverse order an idiomatic way would be to use the <strong>reversed</strong> function:</p>

<pre><code class="python">
for i in reversed([1, 2, 3, 4]):
    print i
   ....:
4
3
2
1
</code></pre>

<p>The <strong>reversed</strong> function would work with any implementation of an iterator, but since an iterator can be used to traverse collection only in one direction, the <strong>reversed</strong> function would need to store all items from the iterator before it would be able to return the first element (which is the last element in the original collection). This is very inefficient especially if we need to iterate over a long collection.</p>

<p>Fortunately in addition to the <strong>__iter__</strong> function Python provides the <strong>__reversed__</strong> function that should return a reversed iterator to go through a collections in the opposite way:</p>

<pre><code class="python">
l = [1, 2, 3, 4]
it = l.__reversed__()

it.next()
&gt;&gt;&gt; 4
it.next()
&gt;&gt;&gt; 3
it.next()
&gt;&gt;&gt; 2
it.next()
&gt;&gt;&gt; 1
it.next()
---------------------------------------------------------------------------
StopIteration                             Traceback (most recent call last)
&lt;ipython-input-21-54f0920595b2&gt; in &lt;module&gt;()
----&gt; 1 it.next()

StopIteration:
</code></pre>

<p>The implementation of the reversed iterator looks very similar. Lets update existing collection to return a reversed iterator:</p>

<pre><code class="python">
class MyList(object):
    def __init__(self, lst):
        self.lst = lst
    ...
    def __reversed__(self):
        return MyReversedIterator(self.lst)
</code></pre>

<p>Iterator implementation is almost the same. The only difference is that we start from the end of the list and go to the first element:</p>

<pre><code class="python">class MyReversedIterator(object):
    def __init__(self, lst):
        self.lst = lst
        self.pos = len(lst) - 1

    def __iter__(self):
        return self

    def next(self):
        if self.pos &lt; 0:
            raise StopIteration()
        elem = self.lst[self.pos]
        self.pos -= 1
        return elem
</code></pre>

<p>Now we can use our object with the <strong>reversed</strong> function:</p>

<pre><code class="python">
for i in reversed(MyList([1, 2, 3, 4])):
    print i

4
3
2
1
</code></pre>

<h2>An iterator is a one-time thing</h2>

<p>Beware that usually you can use an iterator only once and generally there is no way to reset it. This can be a problem especially if you pass an iterator to a function that needs to traverse a collection more than once.</p>

<p>To illustrate it let&rsquo;s say we need to calculate a minimum and a maximum numbers in a sequence:</p>

<pre><code class="python">def min_and_max(seq):
    return min(seq), max(seq)
</code></pre>

<p>Now if we pass a list to this function it will work as expected:</p>

<pre><code class="python">
lst = [5, 2, 10, 34, 0]
min_and_max(lst)
&gt;&gt;&gt; (0, 34)
</code></pre>

<p>But if we pass an iterator we would receive an error instead:</p>

<pre><code class="python">lst = [5, 2, 10, 34, 0]
min_and_max(iter(lst))

Traceback (most recent call last):
  File "&lt;pyshell#65&gt;", line 1, in &lt;module&gt;
    min_and_max(iter(lst))
  File "&lt;pyshell#57&gt;", line 2, in min_and_max
    return min(seq), max(seq)
ValueError: max() arg is an empty sequence
</code></pre>

<p>This is because the <strong>seq</strong> at first is iterated by the <strong>min</strong> function that iterates over all items in it. After that when it is passed to the <strong>max</strong> function, there is no more elements to return.</p>

<p>The correct way to solve this issue would be to store all items from an iterator to a list that can be traversed multiple times:</p>

<pre><code class="python">def min_and_max(seq):
  seq = list(seq)
  return min(seq), max(seq)
</code></pre>

<p>This works because if <strong>list</strong> function is applied to a list it create a copy of a list and if it is applied to an iterator it copies all items from an iterator to a list.</p>

<p>Now it works as expected:</p>

<pre><code class="python">lst = [5, 2, 10, 34, 0]
min_and_max(iter(lst))
(0, 34)
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Implement String Interpolation in Python]]></title>
    <link href="http://mushketyk.github.io/blog/2015/09/05/string-interpolation-in-python/"/>
    <updated>2015-09-05T15:32:28+01:00</updated>
    <id>http://mushketyk.github.io/blog/2015/09/05/string-interpolation-in-python</id>
    <content type="html"><![CDATA[<p>String interpolation is a process of substituting values of local variables into placeholders in a string.</p>

<p>It is implemented in many programming languages such as Scala:</p>

<pre><code class="scala">//Scala 2.10+
var name = "John";
println(s"My name is $name")
&gt;&gt;&gt; My name is John
</code></pre>

<p>Perl:</p>

<pre><code class="perl">my $name = "John";
print "My name is $name";
&gt;&gt;&gt; My name is John
</code></pre>

<p>CoffeeScript:</p>

<pre><code class="coffeescript">name = "John"
console.log "My name is #{name}"
&gt;&gt;&gt; My name is John
</code></pre>

<p>and many others.</p>

<p>On the first sight, it doesn&rsquo;t seem that it&rsquo;s possible to use string interpolation in Python. However, we can implement it with just 2 lines of Python code.</p>

<!--more-->


<p>But let&rsquo;s start with basics. An idiomatic way to build a complex string in Python is to use the &ldquo;format&rdquo; function:</p>

<pre><code class="python">print "Hi, I am {} and I am {} years old".format(name, age)
&gt;&gt;&gt; Hi, I am John and I am 26 years old
</code></pre>

<p>Which is much cleaner than using string concatenation:</p>

<pre><code class="python">print "Hi, I am " + name + " and I am " + str(age) + " years old"
Hi, I am John and I am 26 years old
</code></pre>

<p>But if you use the &ldquo;format&rdquo; function in this way the output depends on the order of arguments:</p>

<pre><code class="python">print "Hi, I am {} and I am {} years old".format(age, name)
Hi, I am 26 and I am John years old
</code></pre>

<p>To avoid that we can pass key-value arguments to the &ldquo;format&rdquo; function:</p>

<pre><code class="python">print "Hi, I am {name} and I am {age} years old".format(name="John", age=26)
Hi, I am John and I am 26 years old

print "Hi, I am {name} and I am {age} years old".format(age=26, name="John")
Hi, I am John and I am 26 years old
</code></pre>

<p>Here we had to pass all variables for string interpolation to the &ldquo;format&rdquo; function, but still we have not achieved what we wanted, because &ldquo;name&rdquo; and &ldquo;age&rdquo; are not local variables. Can &ldquo;format&rdquo; somehow access local variables?</p>

<p>To do it we can get a dictionary with all local variables using the &ldquo;locals&rdquo; function:</p>

<pre><code class="python">name = "John"
age = 26

locals()
&gt;&gt;&gt; {
 ...
 'age': 26,
 'name': 'John',
 ...
}
</code></pre>

<p>Now we just need to somehow pass it to the &ldquo;format&rdquo; function. Unfortunately we cannot just call it as &ldquo;s.format(locals())&rdquo;:</p>

<pre><code class="python">print "Hi, I am {name} and I am {age} years old".format(locals())
---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)
&lt;ipython-input-5-0fb983071eb8&gt; in &lt;module&gt;()
----&gt; 1 print "Hi, I am {name} and I am {age} years old".format(locals())

KeyError: 'name'
</code></pre>

<p>This is because &ldquo;locals()&rdquo; returns a dictionary, while &ldquo;format&rdquo; expects key-value parameters.</p>

<p>Luckily we can convert a dictionary into key-value parameters using &ldquo;**&rdquo; opeartor. If we have a function that expects key-value arguments:</p>

<pre><code class="python">def foo(arg1=None, arg2=None):
    print "arg1 = " + str(arg1)
    print "arg2 = " + str(arg2)
</code></pre>

<p>We can pass parameters packed in a dictionary:</p>

<pre><code class="python">d = {
    'arg1': 1,
    'arg2': 42
}

foo(**d)
&gt;&gt;&gt; arg1 = 1
arg2 = 42
</code></pre>

<p>Now we can use this technique to implement our first version of string interpolation:</p>

<pre><code class="python">print "Hi, I am {name} and I am {age} years old".format(**locals())
Hi, I am John and I am 26 years old
</code></pre>

<p>It works, but looks cumbersome. With this approach every time we need to interpolate our string we would need to write &ldquo;format(**locals())&rdquo;.
It would be great if we could write a function that would interpolate a string like this:</p>

<pre><code class="python"># Can we implement inter() function in Python?
print inter("Hi, I am {name} and I am {age} years old")
&gt;&gt;&gt; Hi, I am John and I am 26 years old
</code></pre>

<p> At first it seems impossible, since if we move interpolation code to another function it would not be able to access local variables from a scope where it was called from:</p>

<pre><code class="python">name = "John"
print inter("My name is {name}")

...

def inter(s):
  # How can we access "name" variable from here?
  return s.format(...)
</code></pre>

<p>And yet, it is possible. Python provides a way to inspect current stack with sys._getframe function:</p>

<pre><code class="python">import sys

def foo():
     foo_var = 'foo'
     bar()


 def bar():
     # sys._getframe(0) would return frame for function "bar"
     # so we need to to access 1-st frame
     # to get local variables from "foo" function
     previous_frame = sys._getframe(1)
     previous_frame_locals = previous_frame.f_locals
     print previous_frame_locals['foo_var']


foo()
&gt;&gt;&gt; foo
</code></pre>

<p>So the only thing that is left is to combine frames introspection with &ldquo;format&rdquo; function. Here are 2 lines of code that would do the trick:</p>

<pre><code class="python">def inter(s):
    return s.format(**sys._getframe(1).f_locals)

name = "John"
age = 26

print inter("Hi, I am {name} and I am {age} years old")
&gt;&gt;&gt; Hi, I am John and I am 26 years old
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sorting Trick in Python]]></title>
    <link href="http://mushketyk.github.io/blog/2015/09/01/sorting-trick-in-python/"/>
    <updated>2015-09-01T08:28:07+01:00</updated>
    <id>http://mushketyk.github.io/blog/2015/09/01/sorting-trick-in-python</id>
    <content type="html"><![CDATA[<p>How would we sort a list of instances of a class like this?</p>

<pre><code class="python">class Person(object):
     def __init__(self, name, age):
         self.name = name
         self.age = age
     def __repr__(self):
         return "Person(name='{}', age={})".format(self.name, self.age)
</code></pre>

<p>One way would be to define a &ldquo;less&rdquo; operator that can be used by a sorting function:</p>

<!--more-->


<pre><code class="python">class Person(object):
     def __init__(self, name, age):
         ...
     def __lt__(self, other):
         return self.name &lt; other.name
     def __repr__(self):
         ...

Person('John', 32) &lt; Person('Boris', 29)
&gt;&gt;&gt; False

Person('John', 32) &gt; Person('Boris', 29)
&gt;&gt;&gt; True
</code></pre>

<p>With this we can sort a list:</p>

<pre><code class="python">people = [Person('John', 32), Person('Boris', 29), Person('Ervin', 26)]

sorted(people)
&gt;&gt;&gt;
[Person(name='Boris', age=29),
 Person(name='Ervin', age=26),
 Person(name='John', age=32)]
</code></pre>

<p>But what if want to sort by different fields in different cases?</p>

<p>Let&rsquo;s say we have class Point with fields &ldquo;x&rdquo; and &ldquo;y&rdquo;:</p>

<pre><code class="python">class Point(object):
     def __init__(self, x, y):
         self.x = x
         self.y = y
     def __repr__(self):
         return "({}, {})".format(self.x, self.y)
</code></pre>

<p>If we need to find <a href="http://www.geeksforgeeks.org/closest-pair-of-points/">closest pair of points</a> we may need to sort an array of points in different cases by &ldquo;x&rdquo; or by &ldquo;y&rdquo; field. Since we can only implement one version of __lt__ method we should find another option.</p>

<p>Let&rsquo;s see how we can overcome this limitation.</p>

<p>At first we can create a function that will extract a value of a field that will be used for sorting:</p>

<pre><code class="python"># "getter" function returns value of "x" field
getter = lambda point: point.x

getter(Point(1, 2))
&gt;&gt;&gt; 1
</code></pre>

<p>Now this function can be used by &ldquo;sorted&rdquo; function to sort a list of points by &ldquo;x&rdquo; field:</p>

<pre><code class="python">sorted(points, key=lambda point: point.x)
&gt;&gt;&gt; [(-1, 4), (0, 6), (1, 42), (1, 2), (1, 5)]
</code></pre>

<p>This works fine, but in Python it can be done with less keystrokes.</p>

<p>Python has the &ldquo;attrgetter&rdquo; function in &ldquo;operator&rdquo; module that can be used to generate a function that we&rsquo;ve implemented manually:</p>

<pre><code class="python">from operator import attrgetter

# "getter" is a function that can extract value of field "x" from
getter = attrgetter('x')

getter(Point(1, 2))
&gt;&gt;&gt; 1
</code></pre>

<p>Now we can pass this function to &ldquo;sorted&rdquo; function as before:</p>

<pre><code class="python">points = [Point(1, 42), Point(1, 2), Point(-1, 4), Point(1, 5), Point(0, 6)]

sorted(points, key=attrgetter('x'))
&gt;&gt;&gt; [(-1, 4), (0, 6), (1, 42), (1, 2), (1, 5)]
</code></pre>

<p>If we would like to sort a list by &ldquo;y&rdquo; field all we need to do is to pass another parameter to &ldquo;attrgetter&rdquo; function:</p>

<pre><code class="python">sorted(points, key=attrgetter('y'))
&gt;&gt;&gt; [(1, 2), (-1, 4), (1, 5), (0, 6), (1, 42)]
</code></pre>

<p>An additional benefit of the &ldquo;attrgetter&rdquo; function is that it can sort items in a list by several fields.</p>

<p>If we want items first to be sorted by &ldquo;x&rdquo; and then by &ldquo;y&rdquo; field we can pass names of those two fields in &ldquo;attrgetter&rdquo;:</p>

<pre><code class="python">sorted(points, key=attrgetter('x', 'y'))
&gt;&gt;&gt; [(-1, 4), (0, 6), (1, 2), (1, 5), (1, 42)]
</code></pre>

<p>Notice that all points with &ldquo;x&rdquo; value equal to 1 are now sorted by &ldquo;y&rdquo; field.</p>

<p>It&rsquo;s interesting to find out how sorting by multiple fields works.</p>

<p>First of all if several arguments are passed to &ldquo;attrgetter&rdquo; it returns an array of values instead of a single value:</p>

<pre><code class="python">getter = attrgetter('x', 'y')

getter(Point(1, 2))
&gt;&gt;&gt; (1, 2)
</code></pre>

<p>So &ldquo;sorted&rdquo; function compares arrays of values when it need to decide if one object is &ldquo;smaller&rdquo; than another one.</p>

<p>When Python compares arrays it first compares element in position 0, if they are different an array with smaller element would be considered to be &ldquo;smaller&rdquo;:</p>

<pre><code class="python">(1, 2) &lt; (2, 2)
&gt;&gt;&gt; True

(1, 2) &lt; (0, 2)
&gt;&gt;&gt; False
</code></pre>

<p>If values in position 0 in both arrays are the same Python would check elements in position 1, then 2, and so on:</p>

<pre><code class="python">(2, 2) &lt; (2, 3)
&gt;&gt;&gt; True

(2, 2) &lt; (2, 2)
&gt;&gt;&gt; False
</code></pre>

<p>While &ldquo;attrgetter&rdquo; is useful for sorting arrays of objects Python also comes with a function that is useful for sorting an array of dictionaries:</p>

<pre><code class="python">from operator import itemgetter

# Function to extract value associated with "key"
getter = itemgetter('key')

getter({'key': 42})
&gt;&gt;&gt; 42
</code></pre>

<p>We can use this function for sorting similarly to how we used &ldquo;attrgetter&rdquo;:</p>

<pre><code class="python">lst = [{'key': 5}, {'key': 0}, {'key': 40}]

sorted(lst, key=itemgetter('key'))
&gt;&gt;&gt; [{'key': 0}, {'key': 5}, {'key': 40}]
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Idiomatic Way to Count in Python]]></title>
    <link href="http://mushketyk.github.io/blog/2015/08/27/idiomatic-way-to-count-in-python/"/>
    <updated>2015-08-27T20:07:29+01:00</updated>
    <id>http://mushketyk.github.io/blog/2015/08/27/idiomatic-way-to-count-in-python</id>
    <content type="html"><![CDATA[<p>Let&rsquo;s say we want to count how many time each item appears in a Python list:</p>

<pre><code class="python">lst = ['fred', 'john', 'mike', 'fred']
</code></pre>

<p>and we expect the following result:</p>

<pre><code class="python">{'mike': 1, 'john': 1, 'fred': 2}
</code></pre>

<p>Here is a simple but not idiomatic solution:</p>

<!--more-->


<pre><code class="python">def count_1(lst):
    res = {}
    for v in lst:
        # if this is the first time we see this value
        if v not in res:
            # set count to 1
            res[v] = 1
        else:
            # increment existing counter
            res[v] += 1
    return res

&gt;&gt;&gt; count_1(lst)
{'mike': 1, 'john': 1, 'fred': 2}
</code></pre>

<p>This solution works, but it is so unPythonic. There should be a way to get rid of this ugly if statement inside the loop.</p>

<p>One way would be to use dict.get() method that can return a specified value if a requested key is not presented in a dictionary:</p>

<pre><code class="python">&gt;&gt;&gt; d = {'key': 'val'}
&gt;&gt;&gt; d.get('key')
'val'
&gt;&gt;&gt; d.get('non-existing', 42)
42
</code></pre>

<p>Now we can use is to rewrite our function:</p>

<pre><code class="python">def count_2(lst):
    res = {}
    for v in lst:
        res[v] = res.get(v, 0) + 1
    return res

&gt;&gt;&gt; count_2(lst)
{'mike': 1, 'john': 1, 'fred': 2}
</code></pre>

<p>This seems to be much better, but we are not done yet. Python has a specialized type of a dictionary that can return a default value for a non existing key. To specify what default value should be returned we can optionally pass a function:</p>

<pre><code class="python">&gt;&gt;&gt; d = defaultdict(lambda: 42)
&gt;&gt;&gt; d['key'] = 'value'
&gt;&gt;&gt; d['non-existing']
42
&gt;&gt;&gt; d['key']
'value'
</code></pre>

<p>Now we can rewrite this function using defaultdict:</p>

<pre><code class="python">&gt;&gt;&gt; def count_3(lst):
    res = defaultdict(lambda: 0)
    for v in lst:
        res[v] += 1
    return res

&gt;&gt;&gt; dict(count_3(l))
{'mike': 1, 'john': 1, 'fred': 2}
</code></pre>

<p>This is much better. But to be really idiomatic we can use Counter class from  <a href="https://docs.python.org/2/library/collections.html">collections</a> library:</p>

<pre><code class="python">&gt;&gt;&gt; count = Counter(l)
&gt;&gt;&gt; dict(count)
{'mike': 1, 'john': 1, 'fred': 2}
</code></pre>

<p>In addtion Counter class also provides more useful methods to work with counts <a href="https://docs.python.org/2/library/collections.html#collections.Counter">operations</a> such as addition of counters, subtraction, intersection, etc.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Wrong Python Decorator and How to Fix It]]></title>
    <link href="http://mushketyk.github.io/blog/2015/08/25/wrong-python-decorator-and-how-to-fix-it/"/>
    <updated>2015-08-25T20:19:02+01:00</updated>
    <id>http://mushketyk.github.io/blog/2015/08/25/wrong-python-decorator-and-how-to-fix-it</id>
    <content type="html"><![CDATA[<p>Let&rsquo;s say you need to write a decorator that measures how long does it take to execute a function. For this task you may write something like this:</p>

<!--more-->


<pre><code class="python">def timeit(func):
    def inner(*args, **kwargs):
        before = datetime.now()
        result = func(*args, **kwargs)
        after = datetime.now()
        diff = after.microsecond - before.microsecond
        print "It took {} ms to execute {}".format(diff, func.__name__)

        return result
    return inner
</code></pre>

<p>So now you can apply this decorator:</p>

<pre><code class="python">@timeit
def fib(n):
    """Returns n-th fibonachi number"""
    if n &lt; 0:
        raise ValueError("Input should be non-negative")
    if n == 0 or n == 1:
        return n
    a, b = 0, 1
    for i in range(1, n+1):
        a, b = b, a + b
    return b
</code></pre>

<p>Which seems to work:</p>

<pre><code class="python">&gt;&gt;&gt; fib(100)
It took 156 ms to execute fib
573147844013817084101L
</code></pre>

<p>Looks fine, but let&rsquo;s try to poke our function in the interpreter:</p>

<pre><code class="python">&gt;&gt;&gt; fib.__name__
'inner'
&gt;&gt;&gt; fib.__doc__
&gt;&gt;&gt;
</code></pre>

<p>It doesn&rsquo;t make sense! This function is &ldquo;fib&rdquo; and not &ldquo;inner&rdquo; and it definitely has a docstring.</p>

<p>Luckily we can easily fix it. We can copy necessary fields from a decorated function:</p>

<pre><code class="python">def timeit(func):
    def inner(*args, **kwargs):
    ...
    inner.__name__ = func.__name__
    inner.__doc__ = func.__doc__
    inner.__module__ = func.__module__
    return inner
</code></pre>

<p>Now it works as expected:</p>

<pre><code class="python">&gt;&gt;&gt; fib.__doc__
'Returns n-th fibonachi number'
&gt;&gt;&gt; fib.__module__
'__main__'
</code></pre>

<p>Alternatively we can use <a href="https://docs.python.org/2/library/functools.html#functools.wraps">wraps</a> function from <a href="https://docs.python.org/2/library/functools.html">functools</a> module:</p>

<pre><code class="python">from functools import wraps

def timeit(func):
  @wraps(func)
    def inner(*args, **kwargs):
    ...
    return inner
</code></pre>

<p>Which provides the same result.</p>
]]></content>
  </entry>
  
</feed>
